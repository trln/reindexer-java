/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.trln.discovery;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import javax.json.bind.Jsonb;
import javax.json.bind.JsonbBuilder;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.*;

public class App {

    private final static Logger logger = LogManager.getLogger(App.class);

    private static Config loadConfig() {
        Jsonb json = JsonbBuilder.create();
        Config config;
        try( FileInputStream inputStream = new FileInputStream("config.json") ) {
            config = json.fromJson(inputStream, Config.class);
            return config;
        } catch( IOException x) {
            throw new RuntimeException(x);
        }
    }


    public static void main(String[] args) throws Exception {
        Config config = loadConfig();
	logger.info("Using solr {}", config.getSolrUrl());
	logger.info("Chunk size {}", config.getChunkSize());
        ExecutorService service =  Executors.newFixedThreadPool(config.getWorkers());

	int queueSize = (int)Math.round(config.getWorkers() * 1.5);
        BlockingQueue<Optional<Path>> pathQueue = new ArrayBlockingQueue<>(queueSize);
	logger.info("File queue holds {}", pathQueue.size());
        List<Future> workers = new ArrayList<>();
        logger.info("Creating {} workers to process argot ingest commands", config.getWorkers());
        for( int i = 0, n = config.getWorkers(); i< n; i++ ) {
            logger.info("Adding handler {}", i+1);
            workers.add(service.submit(new IngestHandler(pathQueue, config.getSolrUrl())));
        }

        DocumentLoader loader = new DocumentLoader(pathQueue, config);
        logger.info("Created document loader.  Starting");
        loader.run();
        logger.info("document loader's work is done");

        logger.info("Sending shutdown message to {} workers", workers.size());
        workers.forEach( w -> {
            Optional<Path> shutdownMessage = Optional.empty();
            try {
                pathQueue.put(shutdownMessage);
            } catch(InterruptedException ix ) {
                logger.warn("interrupted trying to send shutdownnotice");
            }
        } );
        logger.info("Sending shutdown command to thread pool");
        service.shutdown();
        logger.info("Done.");
    }
}
